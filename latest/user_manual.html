<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · IterativeSolvers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IterativeSolvers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="user_manual.html">Manual</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Interface-1">Interface</a></li><li><a class="toctext" href="#ConvergenceHistory-1">ConvergenceHistory</a></li></ul></li><li><span class="toctext">Linear systems</span><ul><li><a class="toctext" href="library/cg.html">Conjugate Gradients</a></li><li><a class="toctext" href="library/chebyshev.html">Chebyshev iteration</a></li><li><a class="toctext" href="library/minres.html">MINRES</a></li><li><a class="toctext" href="library/bicgstabl.html">BiCGStab(l)</a></li><li><a class="toctext" href="library/gmres.html">Restarted GMRES</a></li><li><a class="toctext" href="library/stationary.html">Stationary methods</a></li></ul></li><li><span class="toctext">Eigenproblems</span><ul><li><a class="toctext" href="library/power_method.html">Power method</a></li></ul></li><li><a class="toctext" href="preconditioning.html">Preconditioning</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="library/public.html">Public</a></li><li><a class="toctext" href="library/internal.html">Internal</a></li></ul></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="about/CONTRIBUTING.html">Contributing</a></li><li><a class="toctext" href="about/license.html">License</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="user_manual.html">Manual</a></li></ul><a class="edit-page" href="https://github.com/haampie/IterativeSolvers.jl/tree/94c62f8fbfd4e30978d0973ce76b9076342346a2/docs/src/user_manual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>The package can be installed with a simple instruction.</p><pre><code class="language-julia">julia&gt; Pkg.add(&quot;IterativeSolvers&quot;)</code></pre><p>After installing the package, if you wish to use the latest features of the package you must switch to the master branch with <code>Pkg.clone</code>.</p><pre><code class="language-julia">julia&gt; Pkg.checkout(&quot;IterativeSolvers&quot;)</code></pre><h2><a class="nav-anchor" id="Interface-1" href="#Interface-1">Interface</a></h2><p>All linear-algebraic routines will take as input a linear operator <code>A</code> that maps vectors to vectors. Typically <code>A</code> is a <code>Matrix</code> or a <code>SparseMatrixCSC</code>, but since <code>A</code> is not explicitly typed, any linear operator that supports matrix operations can be used as well. This makes it possible to apply solvers <em>matrix-free</em>. In  IterativeSolvers.jl we strongly recommend <a href="https://github.com/Jutho/LinearMaps.jl">LinearMaps.jl</a>  for non-matrix types of <code>A</code>.</p><p>For matrix-free types of <code>A</code> the following interface is expected to be defined:</p><ul><li><p><code>A*v</code> computes the matrix-vector product on a <code>v::AbstractVector</code>;</p></li><li><p><code>A_mul_B!(y, A, v)</code> computes the matrix-vector product on a <code>v::AbstractVector</code> in-place;</p></li><li><p><code>eltype(A)</code> returns the element type implicit in the equivalent matrix representation of <code>A</code>;</p></li><li><p><code>size(A, d)</code> returns the nominal dimensions along the <code>d</code>th axis in the equivalent matrix representation of <code>A</code>.</p></li></ul><h3><a class="nav-anchor" id="Solvers-1" href="#Solvers-1">Solvers</a></h3><p>All linear solvers have a common function declaration (with a few exceptions).</p><pre><code class="language-none">solver(A, b::Vector; kwargs...)
solver!(x, A, b::Vector; kwargs...)</code></pre><p>In the case of eigenproblems or singular value decompositions:</p><pre><code class="language-none">eigsolver(A; kwargs...)
eigsolver!(x, A; kwargs...)</code></pre><p><code>A</code> is a linear operator as described above.</p><p><code>b</code> is the vector to be solved.</p><p><code>x</code> is a vector for the initial guess. In the case of a mutating call this parameter will be overwritten.</p><p>Output will be the solution to the system.</p><h3><a class="nav-anchor" id="Additional-arguments-1" href="#Additional-arguments-1">Additional arguments</a></h3><p>Keyword names will vary depending on the method, however some of them will always have the same spelling:</p><ul><li><p><code>tol</code>: (relative) stopping tolerance of the method;</p></li><li><p><code>verbose</code>: print information during the iterations;</p></li><li><p><code>maxiter</code>: maximum number of allowed iterations;</p></li><li><p><code>Pl</code> and <code>Pr</code>: left and right preconditioner. See <a href="preconditioning.html#Preconditioning-1">Preconditioning</a>;</p></li><li><p><code>log::Bool = false</code>: output an extra element of type <code>ConvergenceHistory</code> containing the convergence history.</p></li></ul><h3><a class="nav-anchor" id="log-keyword-1" href="#log-keyword-1"><code>log</code> keyword</a></h3><p>Most solvers contain the <code>log</code> keyword. This is to be used when obtaining more information is required, to use it place the set <code>log</code> to <code>true</code>.</p><pre><code class="language-julia">x, ch = cg(Master, rand(10, 10), rand(10) log=true)
svd, L, ch = svdl(Master, rand(100, 100), log=true)</code></pre><p>The function will now return one more parameter of type <code>ConvergenceHistory</code>.</p><h2><a class="nav-anchor" id="ConvergenceHistory-1" href="#ConvergenceHistory-1">ConvergenceHistory</a></h2><p>A <a href="library/public.html#IterativeSolvers.ConvergenceHistory"><code>ConvergenceHistory</code></a> instance stores information of a solver.</p><p>Number of iterations.</p><pre><code class="language-julia">ch.iters</code></pre><p>Convergence status.</p><pre><code class="language-julia">ch.isconverged</code></pre><p>Stopping tolerances. (A <code>Symbol</code> key is needed to access)</p><pre><code class="language-julia">ch[:tol]</code></pre><p>Maximum number of iterations per restart. (Only on restarted methods)</p><pre><code class="language-julia">nrests(ch)</code></pre><p>Number of matrix-vectors and matrix-transposed-vector products.</p><pre><code class="language-julia">nprods(ch)</code></pre><p>Data stored on each iteration, accessed information can be either a vector or matrix. This data can be a lot of things, most commonly residual. (A <code>Symbol</code> key is needed to access)</p><pre><code class="language-julia">ch[:resnorm] #Vector or Matrix
ch[:resnorm, x] #Vector or Matrix element
ch[:resnorm, x, y] #Matrix element</code></pre><p>The available keys of each method is described in the <a href="@ref">Public Documentation</a>.</p><h3><a class="nav-anchor" id="Plotting-1" href="#Plotting-1">Plotting</a></h3><p><code>ConvergeHistory</code> provides a recipe to use with the package <a href="https://github.com/tbreloff/Plots.jl">Plots.jl</a>, this makes it really easy to plot on different plot backends. There are two recipes provided:</p><p>One for the whole <code>ConvergenceHistory</code>.</p><pre><code class="language-julia">plot(ch)</code></pre><p>The other one to plot data binded to a key.</p><pre><code class="language-julia">_, ch = gmres(rand(10,10), rand(10), maxiter = 100, log=true)
plot(ch, :resnorm, sep = :blue)</code></pre><p><em>Plot additional keywords</em></p><p><code>sep::Symbol = :white</code>: color of the line separator in restarted methods.</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="library/cg.html"><span class="direction">Next</span><span class="title">Conjugate Gradients</span></a></footer></article></body></html>
