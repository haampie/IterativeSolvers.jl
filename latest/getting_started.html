<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · IterativeSolvers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IterativeSolvers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="getting_started.html">Getting started</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Interface-1">Interface</a></li><li><a class="toctext" href="#ConvergenceHistory-1">ConvergenceHistory</a></li></ul></li><li><a class="toctext" href="preconditioning.html">Preconditioning</a></li><li><span class="toctext">Linear systems</span><ul><li><a class="toctext" href="linear_systems/cg.html">Conjugate Gradients</a></li><li><a class="toctext" href="linear_systems/chebyshev.html">Chebyshev iteration</a></li><li><a class="toctext" href="linear_systems/minres.html">MINRES</a></li><li><a class="toctext" href="linear_systems/bicgstabl.html">BiCGStab(l)</a></li><li><a class="toctext" href="linear_systems/idrs.html">IDR(s)</a></li><li><a class="toctext" href="linear_systems/gmres.html">Restarted GMRES</a></li><li><a class="toctext" href="linear_systems/lsmr.html">LSMR</a></li><li><a class="toctext" href="linear_systems/lsqr.html">LSQR</a></li><li><a class="toctext" href="linear_systems/stationary.html">Stationary methods</a></li></ul></li><li><span class="toctext">Eigenproblems</span><ul><li><a class="toctext" href="eigenproblems/power_method.html">Power method</a></li></ul></li><li><a class="toctext" href="svd/svdl.html">SVDL</a></li><li><a class="toctext" href="randomized.html">Randomized algorithms</a></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="about/CONTRIBUTING.html">Contributing</a></li><li><a class="toctext" href="about/license.html">License</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="getting_started.html">Getting started</a></li></ul><a class="edit-page" href="https://github.com/haampie/IterativeSolvers.jl/tree/519b9f9926ed8587defd0a37d520466ecdde27b4/docs/src/getting_started.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Getting started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>The package can be installed via Julia&#39;s package manager.</p><pre><code class="language-julia">julia&gt; Pkg.add(&quot;IterativeSolvers&quot;)</code></pre><h2><a class="nav-anchor" id="Interface-1" href="#Interface-1">Interface</a></h2><p>Virtually all solvers have the common function declarations:</p><pre><code class="language-julia">solver(A, args...; kwargs...)
solver!(x, A, args...; kwargs...)</code></pre><p>where <code>A</code> is a <a href="getting_started.html#matrixfree-1">linear operator</a> and <code>x</code> an initial guess. The second declaration also updates <code>x</code> in-place.</p><h3><a class="nav-anchor" id="matrixfree-1" href="#matrixfree-1">Explicit matrices and the matrix-free approach</a></h3><p>Rather than constructing an explicit matrix <code>A</code> of the type <code>Matrix</code> or <code>SparseMatrixCSC</code>, it is also possible to pass a general linear operator that performs matrix operations implicitly. This is called the <strong>matrix-free</strong> approach.</p><p>For matrix-free types of <code>A</code> the following interface is expected to be defined:</p><ul><li><p><code>A*v</code> computes the matrix-vector product on a <code>v::AbstractVector</code>;</p></li><li><p><code>A_mul_B!(y, A, v)</code> computes the matrix-vector product on a <code>v::AbstractVector</code> in-place;</p></li><li><p><code>eltype(A)</code> returns the element type implicit in the equivalent matrix representation of <code>A</code>;</p></li><li><p><code>size(A, d)</code> returns the nominal dimensions along the <code>d</code>th axis in the equivalent matrix representation of <code>A</code>.</p></li></ul><div class="admonition tip"><div class="admonition-title">Matrix-free with LinearMaps.jl</div><div class="admonition-text"><p>We strongly recommend <a href="https://github.com/Jutho/LinearMaps.jl">LinearMaps.jl</a> for matrix-free linear operators, as it implements the above methods already for you; you just have to write the action of the linear map.</p></div></div><h3><a class="nav-anchor" id="Additional-arguments-1" href="#Additional-arguments-1">Additional arguments</a></h3><p>Keyword names will vary depending on the method, however some of them will always have the same spelling:</p><ul><li><p><code>tol</code>: (relative) stopping tolerance of the method;</p></li><li><p><code>verbose</code>: print information during the iterations;</p></li><li><p><code>maxiter</code>: maximum number of allowed iterations;</p></li><li><p><code>Pl</code> and <code>Pr</code>: left and right preconditioner. See <a href="preconditioning.html#Preconditioning-1">Preconditioning</a>;</p></li><li><p><code>log::Bool = false</code>: output an extra element of type <code>ConvergenceHistory</code> containing the convergence history.</p></li></ul><h3><a class="nav-anchor" id="log-keyword-1" href="#log-keyword-1"><code>log</code> keyword</a></h3><p>Most solvers contain the <code>log</code> keyword. This is to be used when obtaining more information is required, to use it place the set <code>log</code> to <code>true</code>.</p><pre><code class="language-julia">x, ch = cg(Master, rand(10, 10), rand(10) log=true)
svd, L, ch = svdl(Master, rand(100, 100), log=true)</code></pre><p>The function will now return one more parameter of type <code>ConvergenceHistory</code>.</p><h2><a class="nav-anchor" id="ConvergenceHistory-1" href="#ConvergenceHistory-1">ConvergenceHistory</a></h2><p>A <a href="getting_started.html#IterativeSolvers.ConvergenceHistory"><code>ConvergenceHistory</code></a> instance stores information of a solver.</p><p>Number of iterations.</p><pre><code class="language-julia">ch.iters</code></pre><p>Convergence status.</p><pre><code class="language-julia">ch.isconverged</code></pre><p>Stopping tolerances. (A <code>Symbol</code> key is needed to access)</p><pre><code class="language-julia">ch[:tol]</code></pre><p>Maximum number of iterations per restart. (Only on restarted methods)</p><pre><code class="language-julia">nrests(ch)</code></pre><p>Number of matrix-vectors and matrix-transposed-vector products.</p><pre><code class="language-julia">nprods(ch)</code></pre><p>Data stored on each iteration, accessed information can be either a vector or matrix. This data can be a lot of things, most commonly residual. (A <code>Symbol</code> key is needed to access)</p><pre><code class="language-julia">ch[:resnorm] #Vector or Matrix
ch[:resnorm, x] #Vector or Matrix element
ch[:resnorm, x, y] #Matrix element</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.ConvergenceHistory" href="#IterativeSolvers.ConvergenceHistory"><code>IterativeSolvers.ConvergenceHistory</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Store general and in-depth information about an iterative method.</p><p><strong>Fields</strong></p><p><code>mvps::Int</code>: number of matrix vector products.</p><p><code>mtvps::Int</code>: number of transposed matrix-vector products</p><p><code>iters::Int</code>: iterations taken by the method.</p><p><code>restart::T</code>: restart relevant information.</p><ul><li><p><code>T == Int</code>: iterations per restart.</p></li><li><p><code>T == Void</code>: methods without restarts.</p></li></ul><p><code>isconverged::Bool</code>: convergence of the method.</p><p><code>data::Dict{Symbol,Any}</code>: Stores all the information stored during the method execution. It stores tolerances, residuals and other information, e.g. Ritz values in <a href="svd/svdl.html#IterativeSolvers.svdl"><code>svdl</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="language-none">ConvergenceHistory()
ConvergenceHistory(restart)</code></pre><p>Create <code>ConvergenceHistory</code> with empty fields.</p><p><strong>Arguments</strong></p><p><code>restart</code>: number of iterations per restart.</p><p><strong>Plots</strong></p><p>Supports plots using the <code>Plots.jl</code> package via a type recipe. Vectors are ploted as series and matrices as scatterplots.</p><p><strong>Implements</strong></p><p><code>Base</code>: <code>getindex</code>, <code>setindex!</code>, <code>push!</code></p></div><a class="source-link" target="_blank" href="https://github.com/haampie/IterativeSolvers.jl/tree/519b9f9926ed8587defd0a37d520466ecdde27b4/src/history.jl#L12-L53">source</a><br/></section><h3><a class="nav-anchor" id="Plotting-1" href="#Plotting-1">Plotting</a></h3><p><code>ConvergeHistory</code> provides a recipe to use with the package <a href="https://github.com/tbreloff/Plots.jl">Plots.jl</a>, this makes it really easy to plot on different plot backends. There are two recipes provided:</p><p>One for the whole <code>ConvergenceHistory</code>.</p><pre><code class="language-julia">plot(ch)</code></pre><p>The other one to plot data binded to a key.</p><pre><code class="language-julia">_, ch = gmres(rand(10,10), rand(10), maxiter = 100, log=true)
plot(ch, :resnorm, sep = :blue)</code></pre><p><em>Plot additional keywords</em></p><p><code>sep::Symbol = :white</code>: color of the line separator in restarted methods.</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="preconditioning.html"><span class="direction">Next</span><span class="title">Preconditioning</span></a></footer></article></body></html>
