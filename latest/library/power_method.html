<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power method · IterativeSolvers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IterativeSolvers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../user_manual.html">Manual</a></li><li><span class="toctext">Linear systems</span><ul><li><a class="toctext" href="cg.html">Conjugate Gradients</a></li><li><a class="toctext" href="chebyshev.html">Chebyshev iteration</a></li><li><a class="toctext" href="minres.html">MINRES</a></li><li><a class="toctext" href="bicgstabl.html">BiCGStab(l)</a></li><li><a class="toctext" href="gmres.html">Restarted GMRES</a></li><li><a class="toctext" href="stationary.html">Stationary methods</a></li></ul></li><li><span class="toctext">Eigenproblems</span><ul><li class="current"><a class="toctext" href="power_method.html">Power method</a><ul class="internal"><li><a class="toctext" href="#Implementation-details-1">Implementation details</a></li></ul></li></ul></li><li><a class="toctext" href="../preconditioning.html">Preconditioning</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="public.html">Public</a></li><li><a class="toctext" href="internal.html">Internal</a></li></ul></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="../about/CONTRIBUTING.html">Contributing</a></li><li><a class="toctext" href="../about/license.html">License</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Eigenproblems</li><li><a href="power_method.html">Power method</a></li></ul><a class="edit-page" href="https://github.com/haampie/IterativeSolvers.jl/tree/94c62f8fbfd4e30978d0973ce76b9076342346a2/docs/src/library/power_method.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Power method</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="(Inverse)-power-method-1" href="#(Inverse)-power-method-1">(Inverse) power method</a></h1><p>Solves the eigenproblem <span>$Ax = λx$</span> approximately where <span>$A$</span> is a general linear map. By default converges towards the dominant eigenpair <span>$(λ, x)$</span> such that <span>$|λ|$</span> is largest. Shift-and-invert can be applied to target a specific eigenvalue near <code>shift</code> in the complex plane.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.powm" href="#IterativeSolvers.powm"><code>IterativeSolvers.powm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">powm(B; kwargs...) -&gt; λ, x, [history]</code></pre><p>See <a href="power_method.html#IterativeSolvers.powm!"><code>powm!</code></a>. Calls <code>powm!(B, x0; kwargs...)</code> with  <code>x0</code> initialized as a random, complex unit vector.</p></div><a class="source-link" target="_blank" href="https://github.com/haampie/IterativeSolvers.jl/tree/94c62f8fbfd4e30978d0973ce76b9076342346a2/src/simple.jl#L63-L68">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.powm!" href="#IterativeSolvers.powm!"><code>IterativeSolvers.powm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">powm!(B, x; shift = zero(eltype(B)), inverse::Bool = false, kwargs...) -&gt; λ, x, [history]</code></pre><p>By default finds the approximate eigenpair <code>(λ, x)</code> of <code>B</code> where <code>|λ|</code> is largest.</p><p><strong>Arguments</strong></p><ul><li><p><code>B</code>: linear map, see the note below.</p></li><li><p><code>x</code>: normalized initial guess. Don&#39;t forget to use complex arithmetic when necessary.</p></li></ul><p><strong>Keywords</strong></p><ul><li><p><code>tol::Real = eps(real(eltype(B))) * size(B, 2) ^ 3</code>: stopping tolerance for the residual norm;</p></li><li><p><code>maxiter::Integer = size(B,2)</code>: maximum number of iterations;</p></li><li><p><code>log::Bool</code>: keep track of the residual norm in each iteration;</p></li><li><p><code>verbose::Bool</code>: print convergence information during the iterations.</p></li></ul><div class="admonition note"><div class="admonition-title">Shift-and-invert</div><div class="admonition-text"><p>When applying shift-and-invert to <span>$Ax = λx$</span> with <code>invert = true</code> and <code>shift = ...</code>, note  that the role of <code>B * b</code> becomes computing <code>inv(A - shift I) * b</code>. So rather than  passing the linear map <span>$A$</span> itself, pass a linear map <code>B</code> that has the action of  shift-and-invert. The eigenvalue is transformed back to an eigenvalue of the actual  matrix <span>$A$</span>.</p></div></div><p><strong>Return values</strong></p><p><strong>if <code>log</code> is <code>false</code></strong></p><ul><li><p><code>λ::Number</code> approximate eigenvalue computed as the Rayleigh quotient;</p></li><li><p><code>x::Vector</code> approximate eigenvector.</p></li></ul><p><strong>if <code>log</code> is <code>true</code></strong></p><ul><li><p><code>λ::Number</code>: approximate eigenvalue computed as the Rayleigh quotient;</p></li><li><p><code>x::Vector</code>: approximate eigenvector;</p></li><li><p><code>history</code>: convergence history.</p></li></ul><p><strong>ConvergenceHistory keys</strong></p><ul><li><p><code>:tol</code> =&gt; <code>::Real</code>: stopping tolerance;</p></li><li><p><code>:resnom</code> =&gt; <code>::Vector</code>: residual norm at each iteration.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using LinearMaps
σ = 1.0 + 1.3im
A = rand(Complex128, 50, 50)
F = lufact(A - σ * I)
Fmap = LinearMap{Complex128}((y, x) -&gt; A_ldiv_B!(y, F, x), 50, ismutating = true)
λ, x = powm(Fmap, inverse = true, shift = σ, tol = 1e-4, maxiter = 200)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/haampie/IterativeSolvers.jl/tree/94c62f8fbfd4e30978d0973ce76b9076342346a2/src/simple.jl#L75-L123">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.invpowm" href="#IterativeSolvers.invpowm"><code>IterativeSolvers.invpowm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">invpowm(B; shift = σ, kwargs...) -&gt; λ, x, [history]</code></pre><p>Find the approximate eigenpair <code>(λ, x)</code> of <span>$A$</span> near <code>shift</code>, where <code>B</code> is a linear map that has the effect <code>B * v = inv(A - σI) * v</code>.</p><p>The method calls <code>powm!(B, x0; inverse = true, shift = σ)</code> with <code>x0</code> a random, complex unit vector. See <a href="power_method.html#IterativeSolvers.powm!"><code>powm!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using LinearMaps
σ = 1.0 + 1.3im
A = rand(Complex128, 50, 50)
F = lufact(A - σ * I)
Fmap = LinearMap{Complex128}((y, x) -&gt; A_ldiv_B!(y, F, x), 50, ismutating = true)
λ, x = invpowm(Fmap, shift = σ, tol = 1e-4, maxiter = 200)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/haampie/IterativeSolvers.jl/tree/94c62f8fbfd4e30978d0973ce76b9076342346a2/src/simple.jl#L156-L175">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.invpowm!" href="#IterativeSolvers.invpowm!"><code>IterativeSolvers.invpowm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">invpowm!(B, x0; shift = σ, kwargs...) -&gt; λ, x, [history]</code></pre><p>Find the approximate eigenpair <code>(λ, x)</code> of <span>$A$</span> near <code>shift</code>, where <code>B</code> is a linear map that has the effect <code>B * v = inv(A - σI) * v</code>.</p><p>The method calls <code>powm!(B, x0; inverse = true, shift = σ)</code>. See <a href="power_method.html#IterativeSolvers.powm!"><code>powm!</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/haampie/IterativeSolvers.jl/tree/94c62f8fbfd4e30978d0973ce76b9076342346a2/src/simple.jl#L182-L189">source</a><br/></section><h2><a class="nav-anchor" id="Implementation-details-1" href="#Implementation-details-1">Implementation details</a></h2><p>Storage requirements are 3 vectors: the approximate eigenvector <code>x</code>, the residual vector <code>r</code> and a temporary. The residual norm lags behind one iteration, as it is computed when <span>$Ax$</span> is performed. Therefore the final resdiual norm is even smaller.</p><footer><hr/><a class="previous" href="stationary.html"><span class="direction">Previous</span><span class="title">Stationary methods</span></a><a class="next" href="../preconditioning.html"><span class="direction">Next</span><span class="title">Preconditioning</span></a></footer></article></body></html>
