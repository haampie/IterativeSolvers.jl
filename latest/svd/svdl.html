<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SVDL · IterativeSolvers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IterativeSolvers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../getting_started.html">Getting started</a></li><li><a class="toctext" href="../preconditioning.html">Preconditioning</a></li><li><span class="toctext">Linear systems</span><ul><li><a class="toctext" href="../linear_systems/cg.html">Conjugate Gradients</a></li><li><a class="toctext" href="../linear_systems/chebyshev.html">Chebyshev iteration</a></li><li><a class="toctext" href="../linear_systems/minres.html">MINRES</a></li><li><a class="toctext" href="../linear_systems/bicgstabl.html">BiCGStab(l)</a></li><li><a class="toctext" href="../linear_systems/idrs.html">IDR(s)</a></li><li><a class="toctext" href="../linear_systems/gmres.html">Restarted GMRES</a></li><li><a class="toctext" href="../linear_systems/lsmr.html">LSMR</a></li><li><a class="toctext" href="../linear_systems/lsqr.html">LSQR</a></li><li><a class="toctext" href="../linear_systems/stationary.html">Stationary methods</a></li></ul></li><li><span class="toctext">Eigenproblems</span><ul><li><a class="toctext" href="../eigenproblems/power_method.html">Power method</a></li></ul></li><li class="current"><a class="toctext" href="svdl.html">SVDL</a><ul class="internal"><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#Implementation-details-1">Implementation details</a></li></ul></li><li><a class="toctext" href="../randomized.html">Randomized algorithms</a></li><li><a class="toctext" href="../iterators.html">The iterator approach</a></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="../about/CONTRIBUTING.html">Contributing</a></li><li><a class="toctext" href="../about/license.html">License</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="svdl.html">SVDL</a></li></ul><a class="edit-page" href="https://github.com/haampie/IterativeSolvers.jl/tree/665cacf98e1e34fb8c5f96bc707548dfd2c6e1ce/docs/src/svd/svdl.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>SVDL</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="SVDL-1" href="#SVDL-1">Golub-Kahan-Lanczos (SVDL)</a></h1><p>The SVDL method computes a partial, approximate SVD decomposition of a general linear operator <span>$A$</span>.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.svdl" href="#IterativeSolvers.svdl"><code>IterativeSolvers.svdl</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">svdl(A) -&gt; Σ, L, [history]</code></pre><p>Compute some singular values (and optionally vectors) using Golub-Kahan-Lanczos bidiagonalization <a href="#footnote-Golub1965">[Golub1965]</a> with thick restarting <a href="#footnote-Wu2000">[Wu2000]</a>.</p><p>If <code>log</code> is set to <code>true</code> is given, method will output a tuple <code>X, L, ch</code>. Where <code>ch</code> is a <code>ConvergenceHistory</code> object. Otherwise it will only return <code>X, L</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>A</code> : The matrix or matrix-like object whose singular values are desired.</p></li></ul><p><strong>Keywords</strong></p><ul><li><p><code>nsv::Int = 6</code>: number of singular values requested;</p></li><li><p><code>v0 = random unit vector</code>: starting guess vector in the domain of <code>A</code>. The length of <code>q</code> should be the number of columns in <code>A</code>;</p></li><li><p><code>k::Int = 2nsv</code>: maximum number of Lanczos vectors to compute before restarting;</p></li><li><p><code>j::Int = nsv</code>: number of vectors to keep at the end of the restart.  We don&#39;t recommend j &lt; nsv;</p></li><li><p><code>maxiter::Int = minimum(size(A))</code>: maximum number of iterations to run;</p></li><li><p><code>verbose::Bool = false</code>: print information at each iteration;</p></li><li><p><code>tol::Real = √eps()</code>: maximum absolute error in each desired singular value;</p></li><li><p><code>reltol::Real=√eps()</code>: maximum error in each desired singular value relative to the  estimated norm of the input matrix;</p></li><li><p><code>method::Symbol=:ritz</code>: restarting algorithm to use. Valid choices are:</p><ol><li><p><code>:ritz</code>: Thick restart with Ritz values [Wu2000].</p></li><li><p><code>:harmonic</code>: Restart with harmonic Ritz values [Baglama2005].</p></li></ol></li><li><p><code>vecs::Symbol = :none</code>: singular vectors to return.</p><ol><li><p><code>:both</code>: Both left and right singular vectors are returned.</p></li><li><p><code>:left</code>: Only the left singular vectors are returned.</p></li><li><p><code>:right</code>: Only the right singular vectors are returned.</p></li><li><p><code>:none</code>: No singular vectors are returned.</p></li></ol></li><li><p><code>dolock::Bool=false</code>: If <code>true</code>, locks converged Ritz values, removing them from the Krylov subspace being searched in the next macroiteration;</p></li><li><p><code>log::Bool = false</code>: output an extra element of type <code>ConvergenceHistory</code> containing extra information of the method execution.</p></li></ul><p><strong>Return values</strong></p><p><strong>if <code>log</code> is <code>false</code></strong></p><ul><li><p><code>Σ</code>: list of the desired singular values if <code>vecs == :none</code> (the default), otherwise  returns an <code>SVD</code> object with the desired singular vectors filled in;</p></li><li><p><code>L</code>: computed partial factorizations of A.</p></li></ul><p><strong>if <code>log</code> is <code>true</code></strong></p><ul><li><p><code>Σ</code>: list of the desired singular values if <code>vecs == :none</code> (the default),</p></li></ul><p>otherwise returns an <code>SVD</code> object with the desired singular vectors filled in;</p><ul><li><p><code>L</code>: computed partial factorizations of A;</p></li><li><p><code>history</code>: convergence history.</p></li></ul><p><strong>ConvergenceHistory keys</strong></p><ul><li><p><code>:betas</code> =&gt; <code>betas</code>: The history of the computed betas.</p></li><li><p><code>:Bs</code> =&gt; <code>Bs</code>: The history of the computed projected matrices.</p></li><li><p><code>:ritz</code> =&gt; <code>ritzvalhist</code>: Ritz values computed at each iteration.</p></li><li><p><code>:conv</code> =&gt; <code>convhist</code>: Convergence data.</p></li></ul><div class="footnote" id="footnote-Golub1965"><a href="#footnote-Golub1965"><strong>[Golub1965]</strong></a><p>Golub, Gene, and William Kahan. &quot;Calculating the singular values and pseudo-inverse  of a matrix.&quot; Journal of the Society for Industrial and Applied Mathematics,  Series B: Numerical Analysis 2.2 (1965): 205-224.</p></div><div class="footnote" id="footnote-Wu2000"><a href="#footnote-Wu2000"><strong>[Wu2000]</strong></a><p>Wu, Kesheng, and Horst Simon. &quot;Thick-restart Lanczos method for large symmetric  eigenvalue problems.&quot; SIAM Journal on Matrix Analysis and Applications 22.2  (2000): 602-616.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haampie/IterativeSolvers.jl/tree/665cacf98e1e34fb8c5f96bc707548dfd2c6e1ce/src/svdl.jl#L85-L154">source</a><br/></section><h2><a class="nav-anchor" id="Implementation-details-1" href="#Implementation-details-1">Implementation details</a></h2><p>The implementation of thick restarting follows closely that of SLEPc as described in <a href="#footnote-Hernandez2008">[Hernandez2008]</a>. Thick restarting can be turned off by setting <code>k = maxiter</code>, but most of the time this is not desirable.</p><p>The singular vectors are computed directly by forming the Ritz vectors from the product of the Lanczos vectors <code>L.P</code>/<code>L.Q</code> and the singular vectors of <code>L.B</code>. Additional accuracy in the singular triples can be obtained using inverse iteration.</p><div class="footnote" id="footnote-Hernandez2008"><a href="#footnote-Hernandez2008"><strong>[Hernandez2008]</strong></a><p>Vicente Hernández, José E. Román, and Andrés Tomás. &quot;A robust and efficient parallel SVD solver based on restarted Lanczos bidiagonalization.&quot; Electronic Transactions on Numerical Analysis 31 (2008): 68-85.</p></div><footer><hr/><a class="previous" href="../eigenproblems/power_method.html"><span class="direction">Previous</span><span class="title">Power method</span></a><a class="next" href="../randomized.html"><span class="direction">Next</span><span class="title">Randomized algorithms</span></a></footer></article></body></html>
